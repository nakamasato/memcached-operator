{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Quickstart for Go-based Operators","text":""},{"location":"#about-this-tutorial","title":"About this tutorial","text":"<p>The original content is https://sdk.operatorframework.io/docs/building-operators/golang/quickstart/. In this tutorial, you can learn to create a go-based operator <code>memcached-operator</code> with operator-sdk step by step.</p> <p>What <code>memcached-operator</code> does: - Manage a custom resource <code>Memcached</code>     - <code>spec.size</code>: specify the number of memcached nodes.     - <code>status.nodes</code>: contain information about nodes. - Implement the reconciliation loop in the controller     - Fetch Memcached instance     - Create Deployment if not exists     - Keep the Memcached's size and Deployment's replicas same     - Update <code>status.nodes</code> with Pod's name.</p>"},{"location":"#prerequisite","title":"Prerequisite","text":"<p>Install the followings:</p> <ol> <li><code>operator-sdk</code>: <code>v1.23.0</code></li> <li><code>go</code>: <code>1.18</code></li> </ol>"},{"location":"#contents","title":"Contents","text":"<ol> <li>Initialize an operator</li> <li>Add API (resource and controller) for Memcached</li> <li>Define Memcached API (Custom Resource Definition)</li> <li>Implement the controller</li> <li>Deploy with Deployment</li> <li>Write controller tests</li> <li>CI</li> </ol>"},{"location":"01-initialize-operator/","title":"1. Create a project","text":"<pre><code>operator-sdk init --domain example.com --repo github.com/example/memcached-operator\n</code></pre> result <pre><code>Writing kustomize manifests for you to edit...\nWriting scaffold for you to edit...\nGet controller runtime:\n$ go get sigs.k8s.io/controller-runtime@v0.10.0\ngo: downloading sigs.k8s.io/controller-runtime v0.10.0\ngo: downloading k8s.io/utils v0.0.0-20210802155522-efc7438f0176\ngo: downloading k8s.io/component-base v0.22.1\ngo: downloading k8s.io/apiextensions-apiserver v0.22.1\nUpdate dependencies:\n$ go mod tidy\nNext: define a resource with:\n$ operator-sdk create api\n</code></pre>"},{"location":"02-create-api/","title":"2. Create API (resource and controller) for Memcached","text":"<ol> <li> <p>Add controller</p> <pre><code>operator-sdk create api --group cache --version v1alpha1 --kind Memcached --resource --controller\n</code></pre> <p>result <pre><code>Writing kustomize manifests for you to edit...\nWriting scaffold for you to edit...\napi/v1alpha1/memcached_types.go\ninternal/controller/memcached_controller.go\nUpdate dependencies:\n$ go mod tidy\nRunning make:\n$ make generate\n/Users/nakamasato/repos/nakamasato/memcached-operator/bin/controller-gen object:headerFile=\"hack/boilerplate.go.txt\" paths=\"./...\"\nNext: implement your new API and generate the manifests (e.g. CRDs,CRs) with:\n$ make manifests\n</code></pre> <li> <p>Try running the empty operator</p> <ol> <li>Install CRD.     <pre><code>make install\n</code></pre></li> <li>Run the controller.     <pre><code>make run\n</code></pre></li> <li>Create a new custom resource <code>Memcached</code>.     <pre><code>kubectl apply -f config/samples/cache_v1alpha1_memcached.yaml\n</code></pre></li> <li>Check logs. (Just confirm the controller starts up successfully.)</li> <li>Cleanup.<ol> <li>Delete CR.     <pre><code>kubectl delete -f config/samples/cache_v1alpha1_memcached.yaml\n</code></pre></li> <li>Stop the controller by <code>ctrl-c</code>.</li> <li>Uninstll the CRD.     <pre><code>make uninstall\n</code></pre></li> </ol> </li> </ol> </li>"},{"location":"03-define-api/","title":"3. Define Memcached API (Custom Resource Definition)","text":"<ol> <li> <p>Update api/v1alpha1/memcached_types.go</p> <pre><code>// MemcachedSpec defines the desired state of Memcached\ntype MemcachedSpec struct {\n    //+kubebuilder:validation:Minimum=0\n    // Size is the size of the memcached deployment\n    Size int32 `json:\"size\"`\n}\n\n// MemcachedStatus defines the observed state of Memcached\ntype MemcachedStatus struct {\n    // Nodes are the names of the memcached pods\n    Nodes []string `json:\"nodes\"`\n}\n</code></pre> </li> <li> <p><code>make generate</code> -&gt; <code>controller-gen</code> to update api/v1alpha1/zz_generated.deepcopy.go</p> </li> <li><code>make manifests</code> -&gt; Make CRD manifests</li> <li>Update config/samples/cache_v1alpha1_memcached.yaml with <code>size: 3</code></li> </ol>"},{"location":"04-implement-controller/","title":"4. Implement the controller","text":""},{"location":"04-implement-controller/#41-fetch-memcached-instance","title":"4.1. Fetch Memcached instance.","text":"<ol> <li> <p>Write the following lines in <code>Reconcile</code> function in internal/controller/memcached_controller.go and import the necessary package.</p> <pre><code>import (\n    \"k8s.io/apimachinery/pkg/api/errors\"\n    // ...\n)\n</code></pre> <pre><code>func (r *MemcachedReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {\n    log := log.FromContext(ctx)\n\n    // 1. Fetch the Memcached instance\n    memcached := &amp;cachev1alpha1.Memcached{}\n    err := r.Get(ctx, req.NamespacedName, memcached)\n    if err != nil {\n        if errors.IsNotFound(err) {\n            log.Info(\"1. Fetch the Memcached instance. Memcached resource not found. Ignoring since object must be deleted\")\n            return ctrl.Result{}, nil\n        }\n        // Error reading the object - requeue the request.\n        log.Error(err, \"1. Fetch the Memcached instance. Failed to get Mmecached\")\n        return ctrl.Result{}, err\n    }\n    log.Info(\"1. Fetch the Memcached instance. Memchached resource found\", \"memcached.Name\", memcached.Name, \"memcached.Namespace\", memcached.Namespace)\n    return ctrl.Result{}, nil\n}\n</code></pre> </li> <li> <p>Check</p> <ol> <li>Run the controller.     <pre><code>make run # if you haven't installed the CRD, you need to run `make install` before running `make run`\n</code></pre></li> <li>Apply a <code>Memcached</code> (CR).     <pre><code>kubectl apply -f config/samples/cache_v1alpha1_memcached.yaml\n</code></pre></li> <li> <p>Check logs.</p> <pre><code>1.651712191392899e+09   INFO    controller.memcached    1. Fetch the Memcached instance. Memchached resource found      {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"memcached.Name\": \"memcached-sample\", \"memcached.Namespace\": \"default\"}\n</code></pre> </li> <li> <p>Delete the CR.     <pre><code>kubectl delete -f config/samples/cache_v1alpha1_memcached.yaml\n</code></pre></p> </li> <li> <p>Check logs.     <pre><code>1.6517122291298392e+09  INFO    controller.memcached    1. Fetch the Memcached instance. Memcached resource not found. Ignoring since object must be deleted    {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\"}\n</code></pre></p> </li> <li>Stop the controller. <code>ctrl-c</code></li> </ol> </li> </ol>"},{"location":"04-implement-controller/#42-check-if-the-deployment-already-exists-and-create-one-if-not-exists","title":"4.2 Check if the deployment already exists, and create one if not exists.","text":"<ol> <li> <p>Add necessary packages to <code>import</code>.     <pre><code>import (\n    ...\n    \"k8s.io/apimachinery/pkg/types\"\n    ...\n\n    appsv1 \"k8s.io/api/apps/v1\"\n    corev1 \"k8s.io/api/core/v1\"\n    metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\n    ...\n)\n</code></pre></p> </li> <li> <p>Add the following logics to <code>Reconcile</code> function.</p> <pre><code>// 2. Check if the deployment already exists, if not create a new one\nfound := &amp;appsv1.Deployment{}\nerr = r.Get(ctx, types.NamespacedName{Name: memcached.Name, Namespace: memcached.Namespace}, found)\nif err != nil &amp;&amp; errors.IsNotFound(err) {\n        // Define a new deployment\n        dep, err := r.deploymentForMemcached(memcached)\n        if err != nil {\n            log.Error(err, \"2. Check if the deployment already exists, if not create a new one. Failed to create new Deployment\", \"memcached.Namespace\", memcached.Namespace, \"memcached.Name\", memcached.Name)\n            return ctrl.Result{}, err\n        }\n        log.Info(\"2. Check if the deployment already exists, if not create a new one. Creating a new Deployment\", \"Deployment.Namespace\", dep.Namespace, \"Deployment.Name\", dep.Name)\n        err = r.Create(ctx, dep)\n        if err != nil {\n                log.Error(err, \"2. Check if the deployment already exists, if not create a new one. Failed to create new Deployment\", \"Deployment.Namespace\", dep.Namespace, \"Deployment.Name\", dep.Name)\n                return ctrl.Result{}, err\n        }\n        // Deployment created successfully - return and requeue\n        return ctrl.Result{Requeue: true}, nil\n} else if err != nil {\n        log.Error(err, \"2. Check if the deployment already exists, if not create a new one. Failed to get Deployment\")\n        return ctrl.Result{}, err\n}\n</code></pre> </li> <li> <p>Create <code>deploymentForMemcached</code> and <code>labelsForMemcached</code> functions.</p> <ol> <li>Initialize <code>appv1.Deployment</code></li> <li>Set the replica size to <code>m.Spec.Size</code> (from <code>Memcached</code> custom resource)</li> <li>Set owner references <code>ctrl.SetControllerReference(m, dep, r.Scheme)</code></li> </ol> <p>deploymentForMemcached <pre><code>// deploymentForMemcached returns a memcached Deployment object\nfunc (r *MemcachedReconciler) deploymentForMemcached(m *cachev1alpha1.Memcached) (*appsv1.Deployment, error) {\n    ls := labelsForMemcached(m.Name)\n    replicas := m.Spec.Size\n\n    dep := &amp;appsv1.Deployment{\n            ObjectMeta: metav1.ObjectMeta{\n                    Name:      m.Name,\n                    Namespace: m.Namespace,\n            },\n            Spec: appsv1.DeploymentSpec{\n                    Replicas: &amp;replicas,\n                    Selector: &amp;metav1.LabelSelector{\n                            MatchLabels: ls,\n                    },\n                    Template: corev1.PodTemplateSpec{\n                            ObjectMeta: metav1.ObjectMeta{\n                                    Labels: ls,\n                            },\n                            Spec: corev1.PodSpec{\n                                    Containers: []corev1.Container{{\n                                            Image:   \"memcached:1.4.36-alpine\",\n                                            Name:    \"memcached\",\n                                            Command: []string{\"memcached\", \"-m=64\", \"-o\", \"modern\", \"-v\"},\n                                            Ports: []corev1.ContainerPort{{\n                                                    ContainerPort: 11211,\n                                                    Name:          \"memcached\",\n                                            }},\n                                    }},\n                            },\n                    },\n            },\n    }\n    // Set Memcached instance as the owner and controller\n    err := ctrl.SetControllerReference(m, dep, r.Scheme)\n    if err != nil {\n        return nil, err\n    }\n    return dep\n}\n</code></pre> <p>labelsForMemcached <pre><code>// labelsForMemcached returns the labels for selecting the resources\n// belonging to the given memcached CR name.\nfunc labelsForMemcached(name string) map[string]string {\n    return map[string]string{\"app\": \"memcached\", \"memcached_cr\": name}\n}\n</code></pre> <li> <p>Add necessary <code>RBAC</code> to the reconciler.</p> <pre><code>//+kubebuilder:rbac:groups=cache.example.com,resources=memcacheds,verbs=get;list;watch;create;update;patch;delete\n//+kubebuilder:rbac:groups=cache.example.com,resources=memcacheds/status,verbs=get;update;patch\n//+kubebuilder:rbac:groups=cache.example.com,resources=memcacheds/finalizers,verbs=update\n+ //+kubebuilder:rbac:groups=apps,resources=deployments,verbs=get;list;watch;create;update;patch;delete\n\nfunc (r *MemcachedReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {\n    // ...\n}\n</code></pre> <p>Run <code>make manifests</code> to update <code>config/rbac/role.yaml</code>.</p> <p>diff <pre><code>--- a/config/rbac/role.yaml\n+++ b/config/rbac/role.yaml\n@@ -5,6 +5,18 @@ metadata:\n   creationTimestamp: null\n   name: manager-role\n rules:\n+- apiGroups:\n+  - apps\n+  resources:\n+  - deployments\n+  verbs:\n+  - create\n+  - delete\n+  - get\n+  - list\n+  - patch\n+  - update\n+  - watch\n</code></pre> <li> <p>Add <code>Owns(&amp;appsv1.Deployment{})</code> to the controller manager.</p> <pre><code> // SetupWithManager sets up the controller with the Manager.\n func (r *MemcachedReconciler) SetupWithManager(mgr ctrl.Manager) error {\n     return ctrl.NewControllerManagedBy(mgr).\n         For(&amp;cachev1alpha1.Memcached{}).\n+        Owns(&amp;appsv1.Deployment{}). // To capture changes of the Deployments owned by this controller\n         Complete(r)\n }\n</code></pre> <ul> <li><code>For</code> specifies the first resource to watch.</li> <li><code>Owns</code> specifies the secondary resource to watch. Only capture changes of the Deployments owned by this controller.</li> </ul> </li> <li> <p>Check</p> <ol> <li>Run the controller.     <pre><code>make run\n</code></pre></li> <li>Apply a <code>Memcached</code> (CR).     <pre><code>kubectl apply -f config/samples/cache_v1alpha1_memcached.yaml\n</code></pre></li> <li> <p>Check logs.</p> <pre><code>1.651716003245384e+09   INFO    controller.memcached    1. Fetch the Memcached instance. Memchached resource found      {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"memcached.Name\": \"memcached-sample\", \"memcached.Namespace\": \"default\"}\n1.651716003245449e+09   INFO    controller.memcached    2. Check if the deployment already exists, if not create a new one. Creating a new Deployment   {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"Deployment.Namespace\": \"default\", \"Deployment.Name\": \"memcached-sample\"}\n1.651716003421142e+09   INFO    controller.memcached    1. Fetch the Memcached instance. Memchached resource found      {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"memcached.Name\": \"memcached-sample\", \"memcached.Namespace\": \"default\"}\n1.651716003426686e+09   INFO    controller.memcached    1. Fetch the Memcached instance. Memchached resource found      {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"memcached.Name\": \"memcached-sample\", \"memcached.Namespace\": \"default\"}\n1.65171600352492e+09    INFO    controller.memcached    1. Fetch the Memcached instance. Memchached resource found      {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"memcached.Name\": \"memcached-sample\", \"memcached.Namespace\": \"default\"}\n1.651716004351556e+09   INFO    controller.memcached    1. Fetch the Memcached instance. Memchached resource found      {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"memcached.Name\": \"memcached-sample\", \"memcached.Namespace\": \"default\"}\n1.6517160069085371e+09  INFO    controller.memcached    1. Fetch the Memcached instance. Memchached resource found      {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"memcached.Name\": \"memcached-sample\", \"memcached.Namespace\": \"default\"}\n1.651716020319972e+09   INFO    controller.memcached    1. Fetch the Memcached instance. Memchached resource found      {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"memcached.Name\": \"memcached-sample\", \"memcached.Namespace\": \"default\"}\n1.651716021237856e+09   INFO    controller.memcached    1. Fetch the Memcached instance. Memchached resource found      {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"memcached.Name\": \"memcached-sample\", \"memcached.Namespace\": \"default\"}\n1.651716025396706e+09   INFO    controller.memcached    1. Fetch the Memcached instance. Memchached resource found      {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"memcached.Name\": \"memcached-sample\", \"memcached.Namespace\": \"default\"}\n</code></pre> <p>There are 10 lines of logs: 1. When <code>Memcached</code> object is created. 1. Create <code>Deployment</code>. 1. Requeued event 1. <code>Deployment</code> creation event and more events are created accordingly. (<code>Owns</code>)</p> </li> <li> <p>Check <code>Deployment</code>.</p> <pre><code>kubectl get deploy memcached-sample\nNAME               READY   UP-TO-DATE   AVAILABLE   AGE\nmemcached-sample   3/3     3            3           19s\n</code></pre> </li> <li> <p>Delete the CR.     <pre><code>kubectl delete -f config/samples/cache_v1alpha1_memcached.yaml\n</code></pre></p> </li> <li> <p>Check logs.     <pre><code>1.651716313736277e+09   INFO    controller.memcached    1. Fetch the Memcached instance. Memcached resource not found. Ignoring since object must be deleted    {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\"}\n1.65171631389033e+09    INFO    controller.memcached    1. Fetch the Memcached instance. Memcached resource not found. Ignoring since object must be deleted    {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\"}\n</code></pre></p> </li> <li>Check <code>Deployment</code>.     <pre><code>kubectl get deploy\nNo resources found in default namespace.\n</code></pre></li> <li>Stop the controller. <code>ctrl-c</code></li> </ol> </li>"},{"location":"04-implement-controller/#43-ensure-the-deployment-size-is-the-same-as-the-spec","title":"4.3 Ensure the deployment size is the same as the spec.","text":"<ol> <li> <p>Add the following lines to <code>Reconcile</code> function.</p> <pre><code>// 3. Ensure the deployment size is the same as the spec\nsize := memcached.Spec.Size\nif *found.Spec.Replicas != size {\n        found.Spec.Replicas = &amp;size\n        err = r.Update(ctx, found)\n        if err != nil {\n                log.Error(err, \"3. Ensure the deployment size is the same as the spec. Failed to update Deployment\", \"Deployment.Namespace\", found.Namespace, \"Deployment.Name\", found.Name)\n                return ctrl.Result{}, err\n        }\n        // Spec updated - return and requeue\n        log.Info(\"3. Ensure the deployment size is the same as the spec. Update deployment size\", \"Deployment.Spec.Replicas\", size)\n        return ctrl.Result{Requeue: true}, nil\n}\n</code></pre> </li> <li> <p>Check</p> <ol> <li> <p>Run the controller.     <pre><code>make run\n</code></pre></p> </li> <li> <p>Apply a <code>Memcached</code> (CR).     <pre><code>kubectl apply -f config/samples/cache_v1alpha1_memcached.yaml\n</code></pre></p> </li> <li> <p>Check <code>Deployment</code>.</p> <pre><code>kubectl get deploy memcached-sample\nNAME               READY   UP-TO-DATE   AVAILABLE   AGE\nmemcached-sample   3/3     3            3           19s\n</code></pre> </li> <li> <p>Change the size to 2 in config/samples/cache_v1alpha1_memcached.yaml</p> <pre><code>kubectl apply -f config/samples/cache_v1alpha1_memcached.yaml\n</code></pre> </li> <li> <p>Check logs.</p> <pre><code>1.6517166666855512e+09  INFO    controller.memcached    1. Fetch the Memcached instance. Memchached resource found      {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"memcached.Name\": \"memcached-sample\", \"memcached.Namespace\": \"default\"}\n1.651716666815873e+09   INFO    controller.memcached    3. Ensure the deployment size is the same as the spec. Update deployment size   {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"Deployment.Spec.Replicas\": 2}\n1.651716666815955e+09   INFO    controller.memcached    1. Fetch the Memcached instance. Memchached resource found      {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"memcached.Name\": \"memcached-sample\", \"memcached.Namespace\": \"default\"}\n1.651716666821547e+09   INFO    controller.memcached    1. Fetch the Memcached instance. Memchached resource found      {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"memcached.Name\": \"memcached-sample\", \"memcached.Namespace\": \"default\"}\n1.65171666694696e+09    INFO    controller.memcached    1. Fetch the Memcached instance. Memchached resource found      {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"memcached.Name\": \"memcached-sample\", \"memcached.Namespace\": \"default\"}\n1.65171666713287e+09    INFO    controller.memcached    1. Fetch the Memcached instance. Memchached resource found      {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"memcached.Name\": \"memcached-sample\", \"memcached.Namespace\": \"default\"}\n</code></pre> </li> <li> <p>Check <code>Deployment</code>.</p> <pre><code>kubectl get deploy\nNAME               READY   UP-TO-DATE   AVAILABLE   AGE\nmemcached-sample   2/2     2            2           115s\n</code></pre> </li> <li> <p>Delete the CR.     <pre><code>kubectl delete -f config/samples/cache_v1alpha1_memcached.yaml\n</code></pre></p> </li> <li> <p>Check logs.     <pre><code>1.65171673062515e+09    INFO    controller.memcached    1. Fetch the Memcached instance. Memcached resource not found. Ignoring since object must be deleted    {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\"}\n1.65171673093264e+09    INFO    controller.memcached    1. Fetch the Memcached instance. Memcached resource not found. Ignoring since object must be deleted    {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\"}\n</code></pre></p> </li> <li>Check <code>Deployment</code>.     <pre><code>kubectl get deploy\nNo resources found in default namespace.\n</code></pre></li> <li>Stop the controller. <code>ctrl-c</code></li> </ol> </li> </ol>"},{"location":"04-implement-controller/#44-update-the-memcached-status-with-the-pod-names","title":"4.4 Update the Memcached status with the pod names.","text":"<ol> <li> <p>Add <code>\"reflect\"</code> to <code>import</code>.     <pre><code>import (\n    \"reflect\"\n    // ...\n)\n</code></pre></p> </li> <li> <p>Add the following logic to <code>Reconcile</code> functioin.</p> <pre><code>// 4. Update the Memcached status with the pod names\n// List the pods for this memcached's deployment\npodList := &amp;corev1.PodList{}\nlistOpts := []client.ListOption{\n        client.InNamespace(memcached.Namespace),\n        client.MatchingLabels(labelsForMemcached(memcached.Name)),\n}\nif err = r.List(ctx, podList, listOpts...); err != nil {\n        log.Error(err, \"4. Update the Memcached status with the pod names. Failed to list pods\", \"Memcached.Namespace\", memcached.Namespace, \"Memcached.Name\", memcached.Name)\n        return ctrl.Result{}, err\n}\npodNames := getPodNames(podList.Items)\nlog.Info(\"4. Update the Memcached status with the pod names. Pod list\", \"podNames\", podNames)\n// Update status.Nodes if needed\nif !reflect.DeepEqual(podNames, memcached.Status.Nodes) {\n        memcached.Status.Nodes = podNames\n        err := r.Status().Update(ctx, memcached)\n        if err != nil {\n                log.Error(err, \"4. Update the Memcached status with the pod names. Failed to update Memcached status\")\n                return ctrl.Result{}, err\n        }\n}\nlog.Info(\"4. Update the Memcached status with the pod names. Update memcached.Status\", \"memcached.Status.Nodes\", memcached.Status.Nodes)\n</code></pre> </li> <li> <p>Add <code>getPodNames</code> function.</p> <pre><code>// getPodNames returns the pod names of the array of pods passed in\nfunc getPodNames(pods []corev1.Pod) []string {\n    var podNames []string\n    for _, pod := range pods {\n            podNames = append(podNames, pod.Name)\n    }\n    return podNames\n}\n</code></pre> </li> <li> <p>Add necessary <code>RBAC</code>.     <pre><code>  //+kubebuilder:rbac:groups=cache.example.com,resources=memcacheds,verbs=get;list;watch;create;update;patch;delete\n  //+kubebuilder:rbac:groups=cache.example.com,resources=memcacheds/status,verbs=get;update;patch\n  //+kubebuilder:rbac:groups=cache.example.com,resources=memcacheds/finalizers,verbs=update\n  //+kubebuilder:rbac:groups=apps,resources=deployments,verbs=get;list;watch;create;update;patch;delete\n+ //+kubebuilder:rbac:groups=core,resources=pods,verbs=get;list;\n</code></pre></p> <p>Run the following command to update <code>config/rbac/role.yaml</code>:</p> <pre><code>make manifests\n</code></pre> </li> <li> <p>Check</p> <ol> <li> <p>Run the controller.     <pre><code>make run\n</code></pre></p> </li> <li> <p>Apply a <code>Memcached</code> (CR).     <pre><code>kubectl apply -f config/samples/cache_v1alpha1_memcached.yaml\n</code></pre></p> </li> <li> <p>Check logs.</p> <pre><code>1.6517855025391748e+09  INFO    controller.memcached    1. Fetch the Memcached instance. Memchached resource found      {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"memcached.Name\": \"memcached-sample\", \"memcached.Namespace\": \"default\"}\n1.6517855025392709e+09  INFO    controller.memcached    2. Check if the deployment already exists, if not create a new one. Creating a new Deployment   {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"Deployment.Namespace\": \"default\", \"Deployment.Name\": \"memcached-sample\"}\n1.6517855026461499e+09  INFO    controller.memcached    1. Fetch the Memcached instance. Memchached resource found      {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"memcached.Name\": \"memcached-sample\", \"memcached.Namespace\": \"default\"}\n1.651785502847106e+09   INFO    controller.memcached    4. Update the Memcached status with the pod names. Pod list     {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"podNames\": []}\n1.651785502847143e+09   INFO    controller.memcached    4. Update the Memcached status with the pod names. Update memcached.Status      {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"memcached.Status.Nodes\": []}\n1.651785502847202e+09   INFO    controller.memcached    1. Fetch the Memcached instance. Memchached resource found      {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"memcached.Name\": \"memcached-sample\", \"memcached.Namespace\": \"default\"}\n1.651785502847241e+09   INFO    controller.memcached    4. Update the Memcached status with the pod names. Pod list     {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"podNames\": []}\n1.651785502848351e+09   INFO    controller.memcached    4. Update the Memcached status with the pod names. Update memcached.Status      {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"memcached.Status.Nodes\": []}\n1.651785502891124e+09   INFO    controller.memcached    1. Fetch the Memcached instance. Memchached resource found      {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"memcached.Name\": \"memcached-sample\", \"memcached.Namespace\": \"default\"}\n1.6517855028911989e+09  INFO    controller.memcached    4. Update the Memcached status with the pod names. Pod list     {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"podNames\": []}\n1.651785502891249e+09   INFO    controller.memcached    4. Update the Memcached status with the pod names. Update memcached.Status      {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"memcached.Status.Nodes\": []}\n1.651785502954266e+09   INFO    controller.memcached    1. Fetch the Memcached instance. Memchached resource found      {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"memcached.Name\": \"memcached-sample\", \"memcached.Namespace\": \"default\"}\n1.6517855029543822e+09  INFO    controller.memcached    4. Update the Memcached status with the pod names. Pod list     {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"podNames\": [\"memcached-sample-5c8cffd96c-wjqsd\", \"memcached-sample-5c8cffd96c-5pthm\"]}\n1.651785503020395e+09   INFO    controller.memcached    4. Update the Memcached status with the pod names. Update memcached.Status      {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"memcached.Status.Nodes\": [\"memcached-sample-5c8cffd96c-wjqsd\", \"memcached-sample-5c8cffd96c-5pthm\"]}\n1.6517855030236201e+09  INFO    controller.memcached    1. Fetch the Memcached instance. Memchached resource found      {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"memcached.Name\": \"memcached-sample\", \"memcached.Namespace\": \"default\"}\n1.651785503023705e+09   INFO    controller.memcached    4. Update the Memcached status with the pod names. Pod list     {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"podNames\": [\"memcached-sample-5c8cffd96c-wjqsd\", \"memcached-sample-5c8cffd96c-5pthm\"]}\n1.6517855030237281e+09  INFO    controller.memcached    4. Update the Memcached status with the pod names. Update memcached.Status      {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"memcached.Status.Nodes\": [\"memcached-sample-5c8cffd96c-wjqsd\", \"memcached-sample-5c8cffd96c-5pthm\"]}\n1.6517855031085582e+09  INFO    controller.memcached    1. Fetch the Memcached instance. Memchached resource found      {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"memcached.Name\": \"memcached-sample\", \"memcached.Namespace\": \"default\"}\n1.651785503108638e+09   INFO    controller.memcached    4. Update the Memcached status with the pod names. Pod list     {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"podNames\": [\"memcached-sample-5c8cffd96c-wjqsd\", \"memcached-sample-5c8cffd96c-5pthm\"]}\n1.651785503108653e+09   INFO    controller.memcached    4. Update the Memcached status with the pod names. Update memcached.Status      {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"memcached.Status.Nodes\": [\"memcached-sample-5c8cffd96c-wjqsd\", \"memcached-sample-5c8cffd96c-5pthm\"]}\n1.65178550697348e+09    INFO    controller.memcached    1. Fetch the Memcached instance. Memchached resource found      {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"memcached.Name\": \"memcached-sample\", \"memcached.Namespace\": \"default\"}\n1.651785506973621e+09   INFO    controller.memcached    4. Update the Memcached status with the pod names. Pod list     {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"podNames\": [\"memcached-sample-5c8cffd96c-wjqsd\", \"memcached-sample-5c8cffd96c-5pthm\"]}\n1.6517855069736378e+09  INFO    controller.memcached    4. Update the Memcached status with the pod names. Update memcached.Status      {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"memcached.Status.Nodes\": [\"memcached-sample-5c8cffd96c-wjqsd\", \"memcached-sample-5c8cffd96c-5pthm\"]}\n1.651785507024296e+09   INFO    controller.memcached    1. Fetch the Memcached instance. Memchached resource found      {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"memcached.Name\": \"memcached-sample\", \"memcached.Namespace\": \"default\"}\n1.651785507024448e+09   INFO    controller.memcached    4. Update the Memcached status with the pod names. Pod list     {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"podNames\": [\"memcached-sample-5c8cffd96c-wjqsd\", \"memcached-sample-5c8cffd96c-5pthm\"]}\n1.651785507024466e+09   INFO    controller.memcached    4. Update the Memcached status with the pod names. Update memcached.Status      {\"reconciler group\": \"cache.example.com\", \"reconciler kind\": \"Memcached\", \"name\": \"memcached-sample\", \"namespace\": \"default\", \"memcached.Status.Nodes\": [\"memcached-sample-5c8cffd96c-wjqsd\", \"memcached-sample-5c8cffd96c-5pthm\"]}\n</code></pre> </li> <li> <p>Check <code>Deployment</code>.</p> <pre><code>kubectl get deploy\nNAME               READY   UP-TO-DATE   AVAILABLE   AGE\nmemcached-sample   2/2     2            2           115s\n</code></pre> </li> <li> <p>Check <code>status</code> in <code>Memcached</code> object.</p> <pre><code>kubectl get Memcached memcached-sample -o jsonpath='{.status}' | jq\n{\n  \"nodes\": [\n    \"memcached-sample-6c765df685-9drvp\",\n    \"memcached-sample-6c765df685-g7nl8\"\n  ]\n}\n</code></pre> </li> <li> <p>Delete the CR.     <pre><code>kubectl delete -f config/samples/cache_v1alpha1_memcached.yaml\n</code></pre></p> </li> <li> <p>Stop the controller. <code>ctrl-c</code></p> </li> </ol> </li> </ol>"},{"location":"05-write-controller-test/","title":"5. Write controller tests","text":""},{"location":"05-write-controller-test/#tools","title":"Tools","text":"<ol> <li>envtest provides libraries for integration testing by starting a local control plane. (<code>etcd</code> an <code>kube-apiserver</code>)</li> <li>Ginkgo BDD framework.</li> <li>Gomega Matcher library for testing.</li> </ol>"},{"location":"05-write-controller-test/#prepare-suite_testgo","title":"Prepare <code>suite_test.go</code>","text":"<ol> <li> <p>Import necessary packages.     <pre><code> import (\n+       \"context\"\n        \"path/filepath\"\n        \"testing\"\n+       ctrl \"sigs.k8s.io/controller-runtime\"\n+\n        . \"github.com/onsi/ginkgo/v2\"\n        . \"github.com/onsi/gomega\"\n        \"k8s.io/client-go/kubernetes/scheme\"\n-       \"k8s.io/client-go/rest\"\n        \"sigs.k8s.io/controller-runtime/pkg/client\"\n        \"sigs.k8s.io/controller-runtime/pkg/envtest\"\n        \"sigs.k8s.io/controller-runtime/pkg/envtest/ter\"\n        logf \"sigs.k8s.io/controller-runtime/pkg/log\"\n        \"sigs.k8s.io/controller-runtime/pkg/log/zap\"\n+       \"sigs.k8s.io/controller-runtime/pkg/manager\"\n</code></pre></p> </li> <li> <p>Prepare global variables.     <pre><code>-var cfg *rest.Config\n-var k8sClient client.Client\n-var testEnv *envtest.Environment\n+var (\n+       k8sClient  client.Client\n+       k8sManager manager.Manager\n+       testEnv    *envtest.Environment\n+       ctx        context.Context\n+       cancel     context.CancelFunc\n+)\n</code></pre></p> </li> <li> <p>Add the following lines at the end of <code>BeforeSuite</code> in <code>internal/controller/suite_test.go</code>.</p> <pre><code>    // Create context with cancel.\n    ctx, cancel = context.WithCancel(context.TODO())\n\n    // Register the schema to manager.\n    k8sManager, err = ctrl.NewManager(cfg, ctrl.Options{\n        Scheme: scheme.Scheme,\n    })\n\n    // Initialize `MemcachedReconciler` with the manager client schema.\n    err = (&amp;MemcachedReconciler{\n        Client: k8sManager.GetClient(),\n        Scheme: k8sManager.GetScheme(),\n    }).SetupWithManager(k8sManager)\n\n    // Start the with a goroutine.\n    go func() {\n        defer GinkgoRecover()\n        err = k8sManager.Start(ctx)\n        Expect(err).ToNot(HaveOccurred(), \"failed to run ger\")\n    }()\n</code></pre> </li> <li> <p>Add <code>cancel()</code> to AfterSuite.</p> <pre><code> var _ = AfterSuite(func() {\n+       cancel()\n        By(\"tearing down the test environment\")\n        err := testEnv.Stop()\n        Expect(err).NotTo(HaveOccurred())\n</code></pre> </li> </ol>"},{"location":"05-write-controller-test/#write-controllers-tests","title":"Write controller's tests","text":"<p>Test cases in <code>internal/controller/memcached_controller_test.go</code>:</p> <ol> <li>When <code>Memcached</code> is created<ol> <li><code>Deployment</code> should be created.</li> <li><code>Memcached</code>'s nodes have pods' names.</li> </ol> </li> <li>When <code>Memcached</code>'s <code>size</code> is updated<ol> <li><code>Deployment</code>'s <code>replicas</code> should be updated.</li> <li><code>Memcached</code>'s nodes have new pods' names.</li> </ol> </li> <li>When <code>Deployment</code> is updated<ol> <li>Deleting <code>Deployment</code> -&gt; <code>Deployment</code> is recreated.</li> <li>Updating <code>Deployment</code> with <code>replicas = 0</code> -&gt; <code>Deployment</code>'s replicas is updated to the original number.</li> </ol> </li> </ol> memcached_controller_test.go <pre><code>package controller\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"time\"\n\n    cachev1alpha1 \"github.com/example/memcached-operator/api/v1alpha1\"\n    . \"github.com/onsi/ginkgo/v2\"\n    . \"github.com/onsi/gomega\"\n\n    appsv1 \"k8s.io/api/apps/v1\"\n    v1 \"k8s.io/api/core/v1\"\n    metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n    \"k8s.io/apimachinery/pkg/types\"\n\n    \"sigs.k8s.io/controller-runtime/pkg/client\"\n)\n\nconst (\n    memcachedApiVersion = \"cache.example.com/v1alphav1\"\n    memcachedKind       = \"Memcached\"\n    memcachedName       = \"sample\"\n    memcachedNamespace  = \"default\"\n    memcachedStartSize  = int32(3)\n    memcachedUpdateSize = int32(10)\n    timeout             = time.Second * 10\n    interval            = time.Millisecond * 250\n)\n\nvar _ = Describe(\"Memcached controller\", func() {\n\n    lookUpKey := types.NamespacedName{Name: memcachedName, Namespace: memcachedNamespace}\n\n    AfterEach(func() {\n        // Delete Memcached\n        deleteMemcached(ctx, lookUpKey)\n        // Delete all Pods\n        deleteAllPods(ctx)\n    })\n\n    Context(\"When creating Memcached\", func() {\n        BeforeEach(func() {\n            // Create Memcached\n            createMemcached(ctx, memcachedStartSize)\n        })\n        It(\"Should create Deployment with the specified size and memcached image\", func() {\n            // Deployment is created\n            deployment := &amp;appsv1.Deployment{}\n            Eventually(func() error {\n                return k8sClient.Get(ctx, lookUpKey, deployment)\n            }, timeout, interval).Should(Succeed())\n            Expect(*deployment.Spec.Replicas).Should(Equal(memcachedStartSize))\n            Expect(deployment.Spec.Template.Spec.Containers[0].Image).Should(Equal(\"memcached:1.4.36-alpine\"))\n            // https://github.com/kubernetes-sigs/controller-runtime/blob/master/pkg/controller/controllerutil/controllerutil_test.go\n            Expect(deployment.OwnerReferences).ShouldNot(BeEmpty())\n        })\n        It(\"Should have pods name in Memcached Node\", func() {\n            checkIfDeploymentExists(ctx, lookUpKey)\n\n            By(\"By creating Pods with labels\")\n            podNames := createPods(ctx, int(memcachedStartSize))\n\n            updateMemcacheSize(ctx, lookUpKey, memcachedUpdateSize) // just to trigger reconcile\n\n            checkMemcachedStatusNodes(ctx, lookUpKey, podNames)\n        })\n    })\n\n    Context(\"When updating Memcached\", func() {\n        BeforeEach(func() {\n            // Create Memcached\n            createMemcached(ctx, memcachedStartSize)\n            // Deployment is ready\n            checkDeploymentReplicas(ctx, lookUpKey, memcachedStartSize)\n        })\n\n        It(\"Should update Deployment replicas\", func() {\n            By(\"Changing Memcached size\")\n            updateMemcacheSize(ctx, lookUpKey, memcachedUpdateSize)\n\n            checkDeploymentReplicas(ctx, lookUpKey, memcachedUpdateSize)\n        })\n\n        It(\"Should update the Memcached status with the pod names\", func() {\n            By(\"Changing Memcached size\")\n            updateMemcacheSize(ctx, lookUpKey, memcachedUpdateSize)\n\n            podNames := createPods(ctx, int(memcachedUpdateSize))\n            checkMemcachedStatusNodes(ctx, lookUpKey, podNames)\n        })\n    })\n    Context(\"When changing Deployment\", func() {\n        BeforeEach(func() {\n            // Create Memcached\n            createMemcached(ctx, memcachedStartSize)\n            // Deployment is ready\n            checkDeploymentReplicas(ctx, lookUpKey, memcachedStartSize)\n        })\n\n        It(\"Should check if the deployment already exists, if not create a new one\", func() {\n            By(\"Deleting Deployment\")\n            deployment := &amp;appsv1.Deployment{}\n            Expect(k8sClient.Get(ctx, lookUpKey, deployment)).Should(Succeed())\n            Expect(k8sClient.Delete(ctx, deployment)).Should(Succeed())\n\n            // Deployment will be recreated by the controller\n            checkIfDeploymentExists(ctx, lookUpKey)\n        })\n\n        It(\"Should ensure the deployment size is the same as the spec\", func() {\n            By(\"Changing Deployment replicas\")\n            deployment := &amp;appsv1.Deployment{}\n            Expect(k8sClient.Get(ctx, lookUpKey, deployment)).Should(Succeed())\n            *deployment.Spec.Replicas = 0\n            Expect(k8sClient.Update(ctx, deployment)).Should(Succeed())\n\n            // replicas will be updated back to the original one by the controller\n            checkDeploymentReplicas(ctx, lookUpKey, memcachedStartSize)\n        })\n    })\n\n    // Deployment is expected to be deleted when Memcached is deleted.\n    // As it's garbage collector's responsibility, which is not part of envtest, we don't test it here.\n})\n\nfunc checkIfDeploymentExists(ctx context.Context, lookUpKey types.NamespacedName) {\n    deployment := &amp;appsv1.Deployment{}\n    Eventually(func() error {\n        return k8sClient.Get(ctx, lookUpKey, deployment)\n    }, timeout, interval).Should(Succeed())\n}\n\nfunc checkDeploymentReplicas(ctx context.Context, lookUpKey types.NamespacedName, expectedSize int32) {\n    Eventually(func() (int32, error) {\n        deployment := &amp;appsv1.Deployment{}\n        err := k8sClient.Get(ctx, lookUpKey, deployment)\n        if err != nil {\n            return int32(0), err\n        }\n        return *deployment.Spec.Replicas, nil\n    }, timeout, interval).Should(Equal(expectedSize))\n}\n\nfunc newMemcached(size int32) *cachev1alpha1.Memcached {\n    return &amp;cachev1alpha1.Memcached{\n        TypeMeta: metav1.TypeMeta{\n            APIVersion: memcachedApiVersion,\n            Kind:       memcachedKind,\n        },\n        ObjectMeta: metav1.ObjectMeta{\n            Name:      memcachedName,\n            Namespace: memcachedNamespace,\n        },\n        Spec: cachev1alpha1.MemcachedSpec{\n            Size: size,\n        },\n    }\n}\n\nfunc createMemcached(ctx context.Context, size int32) {\n    memcached := newMemcached(size)\n    Expect(k8sClient.Create(ctx, memcached)).Should(Succeed())\n}\n\nfunc updateMemcacheSize(ctx context.Context, lookUpKey types.NamespacedName, size int32) {\n    memcached := &amp;cachev1alpha1.Memcached{}\n    Expect(k8sClient.Get(ctx, lookUpKey, memcached)).Should(Succeed())\n    memcached.Spec.Size = size\n    Expect(k8sClient.Update(ctx, memcached)).Should(Succeed())\n}\n\nfunc deleteMemcached(ctx context.Context, lookUpKey types.NamespacedName) {\n    memcached := &amp;cachev1alpha1.Memcached{}\n    Expect(k8sClient.Get(ctx, lookUpKey, memcached)).Should(Succeed())\n    Expect(k8sClient.Delete(ctx, memcached)).Should(Succeed())\n}\n\nfunc checkMemcachedStatusNodes(ctx context.Context, lookUpKey types.NamespacedName, podNames []string) {\n    memcached := &amp;cachev1alpha1.Memcached{}\n    Eventually(func() ([]string, error) {\n        err := k8sClient.Get(ctx, lookUpKey, memcached)\n        if err != nil {\n            return nil, err\n        }\n        return memcached.Status.Nodes, nil\n    }, timeout, interval).Should(ConsistOf(podNames))\n}\n\nfunc createPods(ctx context.Context, num int) []string {\n    podNames := []string{}\n    for i := 0; i &lt; num; i++ {\n        podName := fmt.Sprintf(\"pod-%d\", i)\n        podNames = append(podNames, podName)\n        pod := newPod(podName)\n        Expect(k8sClient.Create(ctx, pod)).Should(Succeed())\n    }\n    return podNames\n}\n\nfunc deleteAllPods(ctx context.Context) {\n    err := k8sClient.DeleteAllOf(ctx, &amp;v1.Pod{}, client.InNamespace(memcachedNamespace))\n    Expect(err).NotTo(HaveOccurred())\n}\n\nfunc newPod(name string) *v1.Pod {\n    return &amp;v1.Pod{\n        TypeMeta: metav1.TypeMeta{\n            Kind:       \"Pod\",\n            APIVersion: \"v1\",\n        },\n        ObjectMeta: metav1.ObjectMeta{\n            Name:      name,\n            Namespace: memcachedNamespace,\n            Labels: map[string]string{\n                \"app\":          \"memcached\",\n                \"memcached_cr\": memcachedName,\n            },\n        },\n        Spec: v1.PodSpec{\n            Containers: []v1.Container{\n                {\n                    Name:  \"memcached\",\n                    Image: \"memcached\",\n                },\n            },\n        },\n        Status: v1.PodStatus{},\n    }\n}\n</code></pre>"},{"location":"05-write-controller-test/#run-the-tests","title":"Run the tests","text":"<pre><code>make test\n</code></pre> <pre><code>/Users/nakamasato/repos/nakamasato/memcached-operator/bin/controller-gen rbac:roleName=manager-role crd webhook paths=\"./...\" output:crd:artifacts:config=config/crd/bases\n/Users/nakamasato/repos/nakamasato/memcached-operator/bin/controller-gen object:headerFile=\"hack/boilerplate.go.txt\" paths=\"./...\"\ngo fmt ./...\ngo vet ./...\nGOBIN=/Users/nakamasato/repos/nakamasato/memcached-operator/bin go install sigs.k8s.io/controller-runtime/tools/setup-envtest@latest\nKUBEBUILDER_ASSETS=\"/Users/nakamasato/Library/Application Support/io.kubebuilder.envtest/k8s/1.23.3-darwin-amd64\" go test ./... -coverprofile cover.out\n?       github.com/example/memcached-operator   [no test files]\n?       github.com/example/memcached-operator/api/v1alpha1      [no test files]\nok      github.com/example/memcached-operator/internal/controller       18.284s coverage: 79.3% of statements\n</code></pre>"},{"location":"06-deploy-operator/","title":"6. Deploy Operator","text":""},{"location":"06-deploy-operator/#61-deploy-with-deployment","title":"6.1 Deploy with <code>Deployment</code>","text":"<ol> <li> <p>Build docker image and push it to registry.</p> <pre><code>export OPERATOR_IMG=\"&lt;image registry name&gt;:v0.0.1\" # e.g. nakamasato/memcached-operator\nmake docker-build docker-push IMG=$OPERATOR_IMG\n</code></pre> </li> <li> <p>Deploy operator.</p> <pre><code>make deploy IMG=$OPERATOR_IMG\n</code></pre> </li> <li> <p>Add CR.</p> <pre><code>kubectl apply -f config/samples/cache_v1alpha1_memcached.yaml\n</code></pre> <pre><code>apiVersion: cache.example.com/v1alpha1\nkind: Memcached\nmetadata:\n  name: memcached-sample\nspec:\n  size: 3\n</code></pre> </li> <li> <p>Check controller's log.</p> <pre><code>kubectl logs $(kubectl get po -n memcached-operator-system | grep memcached-operator-controller-manager | awk '{print $1}') -c manager -n memcached-operator-system -f\n</code></pre> </li> <li> <p>Delete CR.</p> <pre><code>kubectl delete -f config/samples/cache_v1alpha1_memcached.yaml\n</code></pre> </li> <li> <p>Uninstall operator.</p> <pre><code>make undeploy\n</code></pre> </li> </ol>"},{"location":"06-deploy-operator/#62-deploy-with-olm","title":"6.2. Deploy with OLM","text":"<p>Version:</p> <ul> <li>operator-lifecycle-manager: v0.21.1</li> </ul> <p>Steps:</p> <ol> <li> <p>Build and push the latest docker image.</p> <p>In this example, I'm using my own docker hub registry: nakamasato/memcached-operator</p> <pre><code>IMG=nakamasato/memcached-operator:v0.0.1\nIMG=$IMG make docker-build docker-push\n</code></pre> </li> <li> <p>Install OLM into your Kubernetes cluster.</p> <pre><code>operator-sdk olm install\n</code></pre> <p>result <pre><code>INFO[0000] Fetching CRDs for version \"latest\"\nINFO[0000] Fetching resources for resolved version \"latest\"\nI0506 06:39:53.809752   84199 request.go:665] Waited for 1.042948805s due to client-side throttling, not priority and fairness, request: GET:https://127.0.0.1:61181/apis/node.k8s.io/v1beta1?timeout=32s\nINFO[0010] Creating CRDs and resources\nINFO[0010]   Creating CustomResourceDefinition \"catalogsources.operators.coreos.com\"\nINFO[0011]   Creating CustomResourceDefinition \"clusterserviceversions.operators.coreos.com\"\nINFO[0011]   Creating CustomResourceDefinition \"installplans.operators.coreos.com\"\nINFO[0011]   Creating CustomResourceDefinition \"olmconfigs.operators.coreos.com\"\nINFO[0011]   Creating CustomResourceDefinition \"operatorconditions.operators.coreos.com\"\nINFO[0011]   Creating CustomResourceDefinition \"operatorgroups.operators.coreos.com\"\nINFO[0012]   Creating CustomResourceDefinition \"operators.operators.coreos.com\"\nINFO[0012]   Creating CustomResourceDefinition \"subscriptions.operators.coreos.com\"\nINFO[0012]   Creating Namespace \"olm\"\nINFO[0012]   Creating Namespace \"operators\"\nINFO[0012]   Creating ServiceAccount \"olm/olm-operator-serviceaccount\"\nINFO[0012]   Creating ClusterRole \"system:controller:operator-lifecycle-manager\"\nINFO[0012]   Creating ClusterRoleBinding \"olm-operator-binding-olm\"\nINFO[0013]   Creating OLMConfig \"cluster\"\nI0506 06:40:03.832612   84199 request.go:665] Waited for 1.206894542s due to client-side throttling, not priority and fairness, request: GET:https://127.0.0.1:61181/apis/scheduling.k8s.io/v1?timeout=32s\nINFO[0015]   Creating Deployment \"olm/olm-operator\"\nINFO[0015]   Creating Deployment \"olm/catalog-operator\"\nINFO[0015]   Creating ClusterRole \"aggregate-olm-edit\"\nINFO[0015]   Creating ClusterRole \"aggregate-olm-view\"\nINFO[0015]   Creating OperatorGroup \"operators/global-operators\"\nINFO[0015]   Creating OperatorGroup \"olm/olm-operators\"\nINFO[0016]   Creating ClusterServiceVersion \"olm/packageserver\"\nINFO[0016]   Creating CatalogSource \"olm/operatorhubio-catalog\"\nINFO[0016] Waiting for deployment/olm-operator rollout to complete\nINFO[0016]   Waiting for Deployment \"olm/olm-operator\" to rollout: 0 of 1 updated replicas are available\nINFO[0048]   Deployment \"olm/olm-operator\" successfully rolled out\nINFO[0048] Waiting for deployment/catalog-operator rollout to complete\nINFO[0048]   Deployment \"olm/catalog-operator\" successfully rolled out\nINFO[0048] Waiting for deployment/packageserver rollout to complete\nINFO[0048]   Waiting for Deployment \"olm/packageserver\" to rollout: 0 of 2 updated replicas are available\nINFO[0068]   Deployment \"olm/packageserver\" successfully rolled out\nINFO[0069] Successfully installed OLM version \"latest\"\n\nNAME                                            NAMESPACE    KIND                        STATUS\ncatalogsources.operators.coreos.com                          CustomResourceDefinition    Installed\nclusterserviceversions.operators.coreos.com                  CustomResourceDefinition    Installed\ninstallplans.operators.coreos.com                            CustomResourceDefinition    Installed\nolmconfigs.operators.coreos.com                              CustomResourceDefinition    Installed\noperatorconditions.operators.coreos.com                      CustomResourceDefinition    Installed\noperatorgroups.operators.coreos.com                          CustomResourceDefinition    Installed\noperators.operators.coreos.com                               CustomResourceDefinition    Installed\nsubscriptions.operators.coreos.com                           CustomResourceDefinition    Installed\nolm                                                          Namespace                   Installed\noperators                                                    Namespace                   Installed\nolm-operator-serviceaccount                     olm          ServiceAccount              Installed\nsystem:controller:operator-lifecycle-manager                 ClusterRole                 Installed\nolm-operator-binding-olm                                     ClusterRoleBinding          Installed\ncluster                                                      OLMConfig                   Installed\nolm-operator                                    olm          Deployment                  Installed\ncatalog-operator                                olm          Deployment                  Installed\naggregate-olm-edit                                           ClusterRole                 Installed\naggregate-olm-view                                           ClusterRole                 Installed\nglobal-operators                                operators    OperatorGroup               Installed\nolm-operators                                   olm          OperatorGroup               Installed\npackageserver                                   olm          ClusterServiceVersion       Installed\noperatorhubio-catalog                           olm          CatalogSource               Installed\n</code></pre> <p>Check:</p> <pre><code>kubectl get po -n olm\nNAME                                READY   STATUS    RESTARTS      AGE\ncatalog-operator-7bfdc86d78-ftsqp   1/1     Running   0             3m32s\nolm-operator-745fb9c45-xn9jq        1/1     Running   0             3m32s\noperatorhubio-catalog-5spvd         1/1     Running   3 (50s ago)   3m1s\npackageserver-b9659cb48-cmlfn       1/1     Running   0             2m59s\npackageserver-b9659cb48-swpcm       1/1     Running   0             2m59s\n</code></pre> <li> <p>Bundle your operator with <code>BUNDLE_IMG</code>.</p> <pre><code>IMG=$IMG make bundle\n</code></pre> <pre><code>/Users/nakamasato/repos/nakamasato/memcached-operator/bin/controller-gen rbac:roleName=manager-role crd webhook paths=\"./...\" output:crd:artifacts:config=config/crd/bases\noperator-sdk generate kustomize manifests -q\ncd config/manager &amp;&amp; /Users/nakamasato/repos/nakamasato/memcached-operator/bin/kustomize edit set image controller=nakamasato/memcached-operator:v0.0.1\n/Users/nakamasato/repos/nakamasato/memcached-operator/bin/kustomize build config/manifests | operator-sdk generate bundle -q --overwrite --version 0.0.1\nINFO[0001] Creating bundle/metadata/annotations.yaml\nINFO[0001] Creating bundle.Dockerfile\nINFO[0001] Bundle metadata generated suceessfully\noperator-sdk bundle validate ./bundle\nINFO[0000] All validation tests have completed successfully\n</code></pre> <p>Use another repository for bundle: nakamasato/memcached-operator-bundle</p> <pre><code>make bundle-build bundle-push BUNDLE_IMG=docker.io/nakamasato/memcached-operator-bundle:v0.0.1\n</code></pre> <p>result <pre><code>make bundle-build bundle-push BUNDLE_IMG=docker.io/nakamasato/memcached-operator-bundle:v0.0.1\ndocker build -f bundle.Dockerfile -t docker.io/nakamasato/memcached-operator-bundle:v0.0.1 .\n[+] Building 0.5s (7/7) FINISHED\n =&gt; [internal] load build definition from bundle.Dockerfile                                             0.1s\n =&gt; =&gt; transferring dockerfile: 44B                                                                     0.0s\n =&gt; [internal] load .dockerignore                                                                       0.0s\n =&gt; =&gt; transferring context: 35B                                                                        0.0s\n =&gt; [internal] load build context                                                                       0.1s\n =&gt; =&gt; transferring context: 741B                                                                       0.0s\n =&gt; CACHED [1/3] COPY bundle/manifests /manifests/                                                      0.0s\n =&gt; CACHED [2/3] COPY bundle/metadata /metadata/                                                        0.0s\n =&gt; CACHED [3/3] COPY bundle/tests/scorecard /tests/scorecard/                                          0.0s\n =&gt; exporting to image                                                                                  0.0s\n =&gt; =&gt; exporting layers                                                                                 0.0s\n =&gt; =&gt; writing image sha256:7f35a82eb086d5476d518c14d3b467d628032d74a083cd8cb2991ccab57e0707            0.0s\n =&gt; =&gt; naming to docker.io/nakamasato/memcached-operator-bundle:v0.0.1                                  0.0s\n\nUse 'docker scan' to run Snyk tests against images to find vulnerabilities and learn how to fix them\n/Library/Developer/CommandLineTools/usr/bin/make docker-push IMG=docker.io/nakamasato/memcached-operator-bundle:v0.0.1\ndocker push docker.io/nakamasato/memcached-operator-bundle:v0.0.1\nThe push refers to repository [docker.io/nakamasato/memcached-operator-bundle]\n018b84f0bc42: Mounted from nakamasato/memcached-operator-bundle-v0.0.1\n1fe6adf17d6a: Mounted from nakamasato/memcached-operator-bundle-v0.0.1\n3e3e3b47b77a: Mounted from nakamasato/memcached-operator-bundle-v0.0.1\nv0.0.1: digest: sha256:22b7a22279a5f45d9b4eae27ed5e537ae5aeb53ed4ac6572108ba73cf22a8a7a size: 939\n</code></pre> <li> <p>Install <code>memcached-operator</code> with OLM.</p> <pre><code>operator-sdk run bundle docker.io/nakamasato/memcached-operator-bundle:v0.0.1\n</code></pre> <p>result <pre><code>INFO[0023] Successfully created registry pod: docker-io-nakamasato-memcached-operator-bundle-v0-0-1\nINFO[0023] Created CatalogSource: memcached-operator-catalog\nINFO[0023] OperatorGroup \"operator-sdk-og\" created\nINFO[0023] Created Subscription: memcached-operator-v0-0-1-sub\nINFO[0032] Approved InstallPlan install-wq7t2 for the Subscription: memcached-operator-v0-0-1-sub\nINFO[0032] Waiting for ClusterServiceVersion \"default/memcached-operator.v0.0.1\" to reach 'Succeeded' phase\nINFO[0032]   Waiting for ClusterServiceVersion \"default/memcached-operator.v0.0.1\" to appear\nINFO[0066]   Found ClusterServiceVersion \"default/memcached-operator.v0.0.1\" phase: Installing\nINFO[0097]   Found ClusterServiceVersion \"default/memcached-operator.v0.0.1\" phase: Succeeded\nINFO[0097] OLM has successfully installed \"memcached-operator.v0.0.1\"\n</code></pre> <p>Check Pods:</p> <pre><code>kubectl get po\nNAME                                                              READY   STATUS      RESTARTS   AGE\nd71c67e797ef5c5fbbaed16811c5e6052504e58d7c9b2b6e9c19bee2699brks   0/1     Completed   0          112s\ndocker-io-nakamasato-memcached-operator-bundle-v0-0-1             1/1     Running     0          2m6s\nmemcached-operator-controller-manager-c9457868d-s7m2w             2/2     Running     0          78s\n</code></pre> <li> <p>Create Custom Resource.</p> <pre><code>kubectl apply -f config/samples/cache_v1alpha1_memcached.yaml\n</code></pre> <p>Check: <pre><code>kubectl get memcached,deploy memcached-sample\nNAME                                           AGE\nmemcached.cache.example.com/memcached-sample   40s\n\nNAME                               READY   UP-TO-DATE   AVAILABLE   AGE\ndeployment.apps/memcached-sample   2/2     2            2           40s\n</code></pre></p> </li> <li> <p>Clean up the custom resource.</p> <pre><code>kubectl delete -f config/samples/cache_v1alpha1_memcached.yaml\n</code></pre> </li> <li> <p>Uninstall <code>memcached-operator</code>.</p> <pre><code>operator-sdk cleanup memcached-operator\n</code></pre> </li> <li> <p>Uninstall OLM.</p> <pre><code>operator-sdk olm uninstall\n</code></pre> <p>result <pre><code>INFO[0000] Fetching CRDs for version \"v0.21.1\"\nINFO[0000] Fetching resources for resolved version \"v0.21.1\"\nINFO[0003] Uninstalling resources for version \"v0.21.1\"\nINFO[0003]   Deleting CustomResourceDefinition \"catalogsources.operators.coreos.com\"\nINFO[0003]   Deleting CustomResourceDefinition \"clusterserviceversions.operators.coreos.com\"\nINFO[0011]   Deleting CustomResourceDefinition \"installplans.operators.coreos.com\"\nINFO[0018]   Deleting CustomResourceDefinition \"olmconfigs.operators.coreos.com\"\nINFO[0019]   Deleting CustomResourceDefinition \"operatorconditions.operators.coreos.com\"\nINFO[0019]   Deleting CustomResourceDefinition \"operatorgroups.operators.coreos.com\"\nINFO[0023]   Deleting CustomResourceDefinition \"operators.operators.coreos.com\"\nINFO[0024]   Deleting CustomResourceDefinition \"subscriptions.operators.coreos.com\"\nINFO[0024]   Deleting Namespace \"olm\"\nINFO[0037]   Deleting Namespace \"operators\"\nINFO[0043]   Deleting ServiceAccount \"olm/olm-operator-serviceaccount\"\nINFO[0043]     ServiceAccount \"olm/olm-operator-serviceaccount\" does not exist\nINFO[0043]   Deleting ClusterRole \"system:controller:operator-lifecycle-manager\"\nINFO[0043]   Deleting ClusterRoleBinding \"olm-operator-binding-olm\"\nINFO[0043]   Deleting OLMConfig \"cluster\"\nINFO[0043]     OLMConfig \"cluster\" does not exist\nINFO[0044]   Deleting Deployment \"olm/olm-operator\"\nINFO[0044]     Deployment \"olm/olm-operator\" does not exist\nINFO[0044]   Deleting Deployment \"olm/catalog-operator\"\nINFO[0044]     Deployment \"olm/catalog-operator\" does not exist\nINFO[0044]   Deleting ClusterRole \"aggregate-olm-edit\"\nINFO[0044]   Deleting ClusterRole \"aggregate-olm-view\"\nINFO[0044]   Deleting OperatorGroup \"operators/global-operators\"\nINFO[0044]     OperatorGroup \"operators/global-operators\" does not exist\nINFO[0044]   Deleting OperatorGroup \"olm/olm-operators\"\nINFO[0044]     OperatorGroup \"olm/olm-operators\" does not exist\nINFO[0044]   Deleting ClusterServiceVersion \"olm/packageserver\"\nINFO[0044]     ClusterServiceVersion \"olm/packageserver\" does not exist\nINFO[0044]   Deleting CatalogSource \"olm/operatorhubio-catalog\"\nINFO[0044]     CatalogSource \"olm/operatorhubio-catalog\" does not exist\nINFO[0044] Successfully uninstalled OLM version \"v0.21.1\"\n</code></pre>"},{"location":"07-ci/","title":"7. Continuous Integration","text":"<p>Add the following github actions:</p> <ul> <li><code>pre-commit</code></li> <li><code>reviewdog</code></li> <li><code>test</code></li> </ul>"}]}